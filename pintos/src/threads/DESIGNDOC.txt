            +--------------------+
            |        CS 140      |
            | PROJECT 1: THREADS |
            |   DESIGN DOCUMENT  |
            +--------------------+

---- GROUP ----

>> Fill in the names and email addresses of your group members.

FirstName LastName <email@domain.example>
FirstName LastName <email@domain.example>
FirstName LastName <email@domain.example>

---- PRELIMINARIES ----

>> If you have any preliminary comments on your submission, notes for the
>> TAs, or extra credit, please give them here.

>> Please cite any offline or online sources you consulted while
>> preparing your submission, other than the Pintos documentation, course
>> text, lecture notes, and course staff.

                 ALARM CLOCK
                 ===========

---- DATA STRUCTURES ----

>> A1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

---- ALGORITHMS ----

>> A2: Briefly describe what happens in a call to timer_sleep(),
>> including the effects of the timer interrupt handler.

>> A3: What steps are taken to minimize the amount of time spent in
>> the timer interrupt handler?

---- SYNCHRONIZATION ----

>> A4: How are race conditions avoided when multiple threads call
>> timer_sleep() simultaneously?

>> A5: How are race conditions avoided when a timer interrupt occurs
>> during a call to timer_sleep()?

---- RATIONALE ----

>> A6: Why did you choose this design?  In what ways is it superior to
>> another design you considered?

             PRIORITY SCHEDULING
             ===================

---- DATA STRUCTURES ----

>> B1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

在struct lock中添加：
    /*优先级捐赠部分加的*/
    struct list_elem elem;  // 优先级捐赠的线程的队列
    int max_priority;  // 请求该锁的线程中, 优先级最高的
    struct thread *holder;      /* 占有这个锁的线程(for debugging)*/

在struct thread中添加：
    /* 优先级捐赠这部分*/
    int base_priority;  // 起始优先级
    struct list locks;  // 当前线程占有的锁
    struct lock* lock_waitings; // 当前线程请求的锁, 一个锁


>> B2: Explain the data structure used to track priority donation.
>> Use ASCII art to diagram a nested donation.  (Alternately, submit a
>> .png file.)

线程A，优先级31，拥有lock_a
线程B，优先级32，拥有lock_b，想要获取lock_a
线程C，优先级33，想要获取lock_b

优先级捐赠过程放在同目录下B2.png中

---- ALGORITHMS ----

>> B3: How do you ensure that the highest priority thread waiting for
>> a lock, semaphore, or condition variable wakes up first?

当我们需要将一个线程放入就绪队列时，原本使用list_push_back，将其改为list_insert_ordered。
这样保证就绪队列为一个优先级队列，每次率先唤醒的都是优先级最高的线程。

>> B4: Describe the sequence of events when a call to lock_acquire()
>> causes a priority donation.  How is nested donation handled?

事件序列：
1. 判断lock->holder是否为null
2. 若lock->holder不为null，当满足条件：当前线程的优先级>锁的优先级时，执行3，否则执行4
3. 迭代地捐赠优先级
  （1）将lock->max_priority(请求该锁的最高优先级)置为当前线程的优先级
  （2）将当前线程的优先级捐赠给持有该锁的线程
  （3）如果当前锁还被别的锁控制着，将临时存储锁的临时变量置为新的锁，跳转至2
4. 优先级捐赠结束。执行P操作，请求锁，阻塞然后被唤醒，然后获得锁

解决嵌套捐赠：
    按上述过程即可解决此问题，当持有该锁的线程经过优先级捐赠后，若其还在等待其他锁，
则进入持有新锁的线程，并对其进行优先级捐赠，直至所有持锁线程均与第一个请求锁的线程具有相同的优先级为止。

>> B5: Describe the sequence of events when lock_release() is called
>> on a lock that a higher-priority thread is waiting for.

事件序列：
1. 调用list_remove将此锁线程移除
2. 调用thread_update_priority处理线程优先级的改变
  （1）如果这个线程还有锁，就先获取这个线程拥有锁的最大优先级（可能被更高级线程捐赠），
       如果这个优先级比base_priority大的话更新的应该是被捐赠的优先级。
  （2）如果这个线程没有锁，就将此线程优先级置为base_priority（起始优先级）
3. 将此锁的holder置为NULL
4. 释放信号量, 信号量+1

---- SYNCHRONIZATION ----

>> B6: Describe a potential race in thread_set_priority() and explain
>> how your implementation avoids it.  Can you use a lock to avoid
>> this race?

问题：
    当我们调用thread_set_priority进行线程优先级设置的同时，此线程若为锁的持有者，
则可能被优先级捐赠，从而改变优先级。如果这两个过程的顺序不确定，则无法确定最终的优先级为哪个。

解决方法：
    在我们调用thread_set_priority时，首先屏蔽中断，保障设置优先级的过程不会被打断

使用锁：
    我们的实现中没有使用锁来解决此问题。但我们可以考虑给捐赠者和此线程加一个所结构来避免此问题。
但是使用此方法同时会改变线程持有锁的列表，所以需要注意可能会导致的死锁问题。

---- RATIONALE ----

>> B7: Why did you choose this design?  In what ways is it superior to
>> another design you considered?

我们使用list_insert_ordered而不是list_push_back来确保线程的等待队列为一个优先级队列。
这样可以避免每次调度时进行优先级排序从而浪费大量时间。

              ADVANCED SCHEDULER
              ==================

---- DATA STRUCTURES ----

>> C1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

---- ALGORITHMS ----

>> C2: Suppose threads A, B, and C have nice values 0, 1, and 2.  Each
>> has a recent_cpu value of 0.  Fill in the table below showing the
>> scheduling decision and the priority and recent_cpu values for each
>> thread after each given number of timer ticks:

timer  recent_cpu    priority   thread
ticks   A   B   C   A   B   C   to run
-----  --  --  --  --  --  --   ------
 0
 4
 8
12
16
20
24
28
32
36

>> C3: Did any ambiguities in the scheduler specification make values
>> in the table uncertain?  If so, what rule did you use to resolve
>> them?  Does this match the behavior of your scheduler?

>> C4: How is the way you divided the cost of scheduling between code
>> inside and outside interrupt context likely to affect performance?

---- RATIONALE ----

>> C5: Briefly critique your design, pointing out advantages and
>> disadvantages in your design choices.  If you were to have extra
>> time to work on this part of the project, how might you choose to
>> refine or improve your design?

>> C6: The assignment explains arithmetic for fixed-point math in
>> detail, but it leaves it open to you to implement it.  Why did you
>> decide to implement it the way you did?  If you created an
>> abstraction layer for fixed-point math, that is, an abstract data
>> type and/or a set of functions or macros to manipulate fixed-point
>> numbers, why did you do so?  If not, why not?

               SURVEY QUESTIONS
               ================

Answering these questions is optional, but it will help us improve the
course in future quarters.  Feel free to tell us anything you
want--these questions are just to spur your thoughts.  You may also
choose to respond anonymously in the course evaluations at the end of
the quarter.

>> In your opinion, was this assignment, or any one of the three problems
>> in it, too easy or too hard?  Did it take too long or too little time?

>> Did you find that working on a particular part of the assignment gave
>> you greater insight into some aspect of OS design?

>> Is there some particular fact or hint we should give students in
>> future quarters to help them solve the problems?  Conversely, did you
>> find any of our guidance to be misleading?

>> Do you have any suggestions for the TAs to more effectively assist
>> students, either for future quarters or the remaining projects?

>> Any other comments?